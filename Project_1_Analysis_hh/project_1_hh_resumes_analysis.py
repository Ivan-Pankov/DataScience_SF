# -*- coding: utf-8 -*-
"""Project_1_hh_Resumes_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HZq0vyIyP2A4rBDtD1rGdPqEPuBls7OL

<center> <img src = https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/hh%20label.jpg alt="drawing" style="width:400px;">

# <center> Проект: Анализ резюме из HeadHunter
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from plotly.subplots import make_subplots
import plotly
import plotly.express as px
import plotly.graph_objs as go

print(plotly.__version__)

"""# Исследование структуры данных

1. Прочитайте данные с помощью библиотеки Pandas. Совет: перед чтением обратите внимание на разделитель внутри файла.
"""

hh_df = pd.read_csv('dst-3.0_16_1_hh_database.csv.zip', sep=';')

"""2. Выведите несколько первых (последних) строк таблицы, чтобы убедиться в том, что ваши данные не повреждены. Ознакомьтесь с признаками и их структурой."""

hh_df.head(3)

hh_df.shape
# Для анализа имеем 12 многосоставных критериев (в один столбец внесены сразу несколько параметров) и более 44 тысяч резюме

"""3. Выведите основную информацию о числе непустых значений в столбцах и их типах в таблице."""

hh_df_null = hh_df.isnull().sum()
hh_df_null[hh_df_null>0]

"""4. Обратите внимание на информацию о числе непустых значений."""

hh_df_null_percent = hh_df.isnull().mean() * 100
hh_df_with_null = hh_df_null_percent[hh_df_null_percent>0].sort_values(ascending=False)
hh_df_with_null

"""### Выведем общее количество пропуском в виде тепловой карты по всему датафрейму."""

px.imshow(hh_df.isnull().astype('int'))

"""5. Выведите основную статистическую информацию о столбцах.

"""

hh_df.describe()

"""# Преобразование данных

1. Начнем с простого - с признака **"Образование и ВУЗ"**. Его текущий формат это: **<Уровень образования год выпуска ВУЗ специальность...>**. Например:
* Высшее образование 2016 Московский авиационный институт (национальный исследовательский университет)...
* Неоконченное высшее образование 2000  Балтийская государственная академия рыбопромыслового флота…
Нас будет интересовать только уровень образования.

Создайте с помощью функции-преобразования новый признак **"Образование"**, который должен иметь 4 категории: "высшее", "неоконченное высшее", "среднее специальное" и "среднее".

Выполните преобразование, ответьте на контрольные вопросы и удалите признак "Образование и ВУЗ".

Совет: обратите внимание на структуру текста в столбце **"Образование и ВУЗ"**. Гарантируется, что текущий уровень образования соискателя всегда находится в первых 2ух слов и начинается с заглавной буквы. Воспользуйтесь этим.

*Совет: проверяйте полученные категории, например, с помощью метода unique()*
"""

#Создаем с помощью lambda функции новый признак "Образование" выделяя часть с образованием
hh_df["Образование"] = hh_df["Образование и ВУЗ"].apply(lambda x: ' '.join(x.split(' '))[:10])

#Выделяем и переименовываем 4 категории: "высшее", "неоконченное высшее", "среднее специальное" и "среднее".
hh_df.loc[(hh_df["Образование"] == 'Неоконченн', ("Образование"))] = 'неоконченное высшее'
hh_df.loc[(hh_df["Образование"] == 'Среднее сп', ("Образование"))] = 'среднее специальное'
hh_df.loc[(hh_df["Образование"] == 'Высшее обр', ("Образование"))] = 'высшее'
hh_df.loc[(hh_df["Образование"] == 'Среднее об', ("Образование"))] = 'среднее'

#Проверяем, что кроме 4 категорий нет лишних
hh_df["Образование"].unique()

#удаляем столбец "Образование и ВУЗ"
hh_df = hh_df.drop('Образование и ВУЗ', axis=1)


print(hh_df['Образование'].value_counts()['среднее'])

"""### 2. Теперь нас интересует столбец **"Пол, возраст"**.
Сейчас он представлен в формате **<Пол , возраст , дата рождения >**. Например:
* Мужчина , 39 лет , родился 27 ноября 1979
* Женщина , 21 год , родилась 13 января 2000
Как вы понимаете, нам необходимо выделить каждый параметр в отдельный столбец.

Создайте два новых признака **"Пол"** и **"Возраст"**. При этом важно учесть:
* Признак пола должен иметь 2 уникальных строковых значения: 'М' - мужчина, 'Ж' - женщина.
* Признак возраста должен быть представлен целыми числами.

Выполните преобразование, ответьте на контрольные вопросы и удалите признак **"Пол, возраст"** из таблицы.

*Совет: обратите внимание на структуру текста в столбце, в части на то, как разделены параметры пола, возраста и даты рождения между собой - символом ' , '.
Гарантируется, что структура одинакова для всех строк в таблице. Вы можете воспользоваться этим.*

"""

#Создаем с помощью lambda функции новый признак "Пол" выделяя часть указанием пола: 'М' - мужчина, 'Ж' - женщина.
hh_df["Пол"] = hh_df["Пол, возраст"].apply(lambda x: x[0].split(',')[0])

#Проверим список уникальных значений и отсутствие пропусков.
display(hh_df["Пол"].unique())

#Найдем процент женских резюме представленых в наших данных
display(hh_df["Пол"].value_counts(normalize=True).round(2))


#Создаем с помощью lambda функции новый признак "Возраст", преобразовав признак к типу целочисленных данных.
hh_df["Возраст"] = hh_df["Пол, возраст"].apply(lambda x: x.split(',')[1])
hh_df["Возраст"] = hh_df["Возраст"].apply(lambda x: x.strip().split(' ')[0])
hh_df["Возраст"] = hh_df["Возраст"].astype("Int8")

#Проверим список уникальных значений и отсутствие пропусков.
display(hh_df["Возраст"].unique())
display(hh_df["Возраст"].max()) #Есть соискатель в возрасте 100 лет!!! Круто))

#Найдем средний возраст соискателе1
hh_df["Возраст"].mean().round(1)

#удаляем столбец "Пол, возраст"
hh_df = hh_df.drop('Пол, возраст', axis=1)

"""### 3. Следующим этапом преобразуем признак **"Опыт работы"**.
Его текущий формат - это: **<Опыт работы: n лет m месяцев, периоды работы в различных компаниях…>**.

Из столбца нам необходимо выделить общий опыт работы соискателя в месяцах, новый признак назовем "Опыт работы (месяц)"

Для начала обсудим условия решения задачи:
* Во-первых, в данном признаке есть пропуски. Условимся, что если мы встречаем пропуск, оставляем его как есть (функция-преобразование возвращает NaN)
* Во-вторых, в данном признаке есть скрытые пропуски. Для некоторых соискателей в столбце стоит значения "Не указано". Их тоже обозначим как NaN (функция-преобразование возвращает NaN)
* В-третьих, нас не интересует информация, которая описывается после указания опыта работы (периоды работы в различных компаниях)
* В-четвертых, у нас есть проблема: опыт работы может быть представлен только в годах или только месяцах. Например, можно встретить следующие варианты:
    * Опыт работы 3 года 2 месяца…
    * Опыт работы 4 года…
    * Опыт работы 11 месяцев…
    * Учитывайте эту особенность в вашем коде

Учитывайте эту особенность в вашем коде

В результате преобразования у вас должен получиться столбец, содержащий информацию о том, сколько месяцев проработал соискатель.
Выполните преобразование, ответьте на контрольные вопросы и удалите столбец **"Опыт работы"** из таблицы.

"""

def get_exp(text):
    if text is np.nan:
        return None
    year_words=['год', 'года', 'лет']
    month_words=['месяц', 'месяца', 'месяцев']
    text_splitted = text.split(' ')[:7]
    years = 0
    months = 0
    for i, value in enumerate (text_splitted):
        if value in year_words:
            years = int(text_splitted[i-1])
        if value in month_words:
            months = int(text_splitted[i-1])
    return int(years*12 + months)

hh_df["Опыт работы (месяц)"] = hh_df["Опыт работы"].apply(get_exp)

#Найдем медианный опыт работы (в месяцах)
display(hh_df["Опыт работы (месяц)"].median()) # .round()

#удаляем столбец "Опыт работы"
hh_df = hh_df.drop('Опыт работы', axis=1)

"""### 4. Хорошо идем! Следующий на очереди признак "Город, переезд, командировки".
Информация в нем представлена в следующем виде: **<Город , (метро) , готовность к переезду (города для переезда) , готовность к командировкам>**. В скобках указаны необязательные параметры строки. Например, можно встретить следующие варианты:

* Москва , не готов к переезду , готов к командировкам
* Москва , м. Беломорская , не готов к переезду, не готов к командировкам
* Воронеж , готов к переезду (Сочи, Москва, Санкт-Петербург) , готов к командировкам

Создадим отдельные признаки **"Город"**, **"Готовность к переезду"**, **"Готовность к командировкам"**. При этом важно учесть:

* Признак **"Город"** должен содержать только 4 категории: "Москва", "Санкт-Петербург" и "город-миллионник" (их список ниже), остальные обозначьте как "другие".

    Список городов-миллионников:
    
   <code>million_cities = ['Новосибирск', 'Екатеринбург','Нижний Новгород','Казань', 'Челябинск','Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж','Волгоград']
    </code>
    Инфорация о метро, рядом с которым проживает соискатель нас не интересует.
* Признак **"Готовность к переезду"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к переезду в признаке "Город, переезд, командировки". Например:
    * … , готов к переезду , …
    * … , не готова к переезду , …
    * … , готова к переезду (Москва, Санкт-Петербург, Ростов-на-Дону)
    * … , хочу переехать (США) , …
    
    Нас интересует только сам факт возможности или желания переезда.
* Признак **"Готовность к командировкам"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к командировкам в признаке "Город, переезд, командировки". Например:
    * … , готов к командировкам , …
    * … , готова к редким командировкам , …
    * … , не готов к командировкам , …
    
    Нас интересует только сам факт готовности к командировке.
    
    Еще один важный факт: при выгрузки данных у некоторых соискателей "потерялась" информация о готовности к командировкам. Давайте по умолчанию будем считать, что такие соискатели не готовы к командировкам.
    
Выполните преобразования и удалите столбец **"Город, переезд, командировки"** из таблицы.

*Совет: обратите внимание на то, что структура текста может меняться в зависимости от указания ближайшего метро. Учите это, если будете использовать порядок слов в своей программе.*

"""

#Выделим признак "Город"
hh_df["Город"] = hh_df["Город, переезд, командировки"].apply(lambda x: x.split(' ,')[0])

def change_city(city):   #преобразуем значения городов до 4 признаков.
    million_cities = [
        'Новосибирск', 'Екатеринбург', 'Нижний Новгород',
        'Казань', 'Челябинск', 'Омск', 'Самара',
        'Ростов-на-Дону', 'Уфа', 'Красноярск',
        'Пермь', 'Воронеж', 'Волгоград'
    ]
    if (city == 'Москва') or (city == 'Санкт-Петербург'):
        return city
    elif city in million_cities:
        return 'город миллионник'
    else:
        return 'другие'


hh_df["Город"] = hh_df["Город"].apply(change_city)
hh_df["Город"].unique()

#Найдем процент соискателей в проживающих в Санкт-Петербурге
hh_df["Город"].value_counts(normalize=True).round(2)*100

#Выделим признак "Готовность к переезду"
def relocation_transformer(v):
    if ('не готов к переезду' in v) or ('не готова к переезду' in v):
        return False
    else:
        return True


hh_df["Готовность к переезду"] = hh_df["Город, переезд, командировки"].apply(relocation_transformer)
hh_df["Готовность к переезду"].value_counts()

#Выделим признак "Готовность к командировкам"
def business_trip_transformer(v):
    if ('не готов к командировкам' in v) or('не готова к командировкам' in v):
        return False
    else:
        return True


hh_df["Готовность к командировкам"] = hh_df["Город, переезд, командировки"].apply(business_trip_transformer)
hh_df["Готовность к командировкам"].value_counts()

#удаляем столбец "Город, переезд, командировки"
hh_df = hh_df.drop('Город, переезд, командировки', axis=1)

#Найдем процент соискателей готовых одновременно и к переездам, и к командировкам
round(hh_df[hh_df['Готовность к переезду'] & hh_df['Готовность к командировкам']].shape[0] / hh_df.shape[0] *100)

"""### 5. Рассмотрим поближе признаки **"Занятость"** и **"График"**.
Сейчас признаки представляют собой набор категорий желаемой занятости (полная занятость, частичная занятость, проектная работа, волонтерство, стажировка) и желаемого графика работы (полный день, сменный график, гибкий график, удаленная работа, вахтовый метод).
На сайте hh.ru соискатель может указывать различные комбинации данных категорий, например:
* полная занятость, частичная занятость
* частичная занятость, проектная работа, волонтерство
* полный день, удаленная работа
* вахтовый метод, гибкий график, удаленная работа, полная занятость

Такой вариант признаков имеет множество различных комбинаций, а значит множество уникальных значений, что мешает анализу. Нужно это исправить!

Давайте создадим признаки-мигалки для каждой категории: если категория присутствует в списке желаемых соискателем, то в столбце на месте строки рассматриваемого соискателя ставится True, иначе - False.

Такой метод преобразования категориальных признаков называется One Hot Encoding и его схема представлена на рисунке ниже:
<img src=https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/ohe.jpg>
Выполните данное преобразование для признаков "Занятость" и "График", ответьте на контрольные вопросы, после чего удалите их из таблицы
"""

mask = {
    'Занятость': ['полная занятость', 'частичная занятость', 'проектная работа', 'волонтерство', 'стажировка'],
    'График': ['полный день', 'сменный график', 'гибкий график', 'удаленная работа', 'вахтовый метод']
}
for key in mask:
    for i in mask[key]:
        hh_df[i] = hh_df[key].apply(lambda x: i in x)

#удаляем столбцы "Занятость" и "График"
hh_df.drop(mask.keys(), axis=1, inplace=True)

#Найдем количество людей, которые ищут проектную работу или волонтёрство
a = hh_df[hh_df['проектная работа'] & hh_df['волонтерство']].shape[0]
display(f"количество людей, которые ищут проектную работу или волонтёрств: {a}")

#Найдем количество людей, которые хотят работать вахтовым методом или с гибким графиком
b = hh_df[hh_df['вахтовый метод'] & hh_df['гибкий график']].shape[0]
display(f"количество людей, которые хотят работать вахтовым методом или с гибким графикомв: {b}")

"""### 6. (2 балла) Наконец, мы добрались до самого главного и самого важного - признака заработной платы **"ЗП"**.
В чем наша беда? В том, что помимо желаемой заработной платы соискатель указывает валюту, в которой он бы хотел ее получать, например:
* 30000 руб.
* 50000 грн.
* 550 USD

Нам бы хотелось видеть заработную плату в единой валюте, например, в рублях. Возникает вопрос, а где взять курс валют по отношению к рублю?

На самом деле язык Python имеет в арсенале огромное количество возможностей получения данной информации, от обращения к API Центробанка, до использования специальных библиотек, например pycbrf. Однако, это не тема нашего проекта.

Поэтому мы пойдем в лоб: обратимся к специальным интернет-ресурсам для получения данных о курсе в виде текстовых файлов. Например, MDF.RU, данный ресурс позволяет удобно экспортировать данные о курсах различных валют и акций за указанные периоды в виде csv файлов. Мы уже сделали выгрузку курсов валют, которые встречаются в наших данных за период с 29.12.2017 по 05.12.2019. Скачать ее вы можете **на платформе**

Создайте новый DataFrame из полученного файла. В полученной таблице нас будут интересовать столбцы:
* "currency" - наименование валюты в ISO кодировке,
* "date" - дата,
* "proportion" - пропорция,
* "close" - цена закрытия (последний зафиксированный курс валюты на указанный день).


Перед вами таблица соответствия наименований иностранных валют в наших данных и их общепринятых сокращений, которые представлены в нашем файле с курсами валют. Пропорция - это число, за сколько единиц валюты указан курс в таблице с курсами. Например, для казахстанского тенге курс на 20.08.2019 составляет 17.197 руб. за 100 тенге, тогда итоговый курс равен - 17.197 / 100 = 0.17197 руб за 1 тенге.
Воспользуйтесь этой информацией в ваших преобразованиях.

<img src=https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/table.jpg>


Осталось только понять, откуда брать дату, по которой определяется курс? А вот же она - в признаке **"Обновление резюме"**, в нем содержится дата и время, когда соискатель выложил текущий вариант своего резюме. Нас интересует только дата, по ней бы и будем сопоставлять курсы валют.

Теперь у нас есть вся необходимая информация для того, чтобы создать признак "ЗП (руб)" - заработная плата в рублях.

После ответа на контрольные вопросы удалите исходный столбец заработной платы "ЗП" и все промежуточные столбцы, если вы их создавали.

Итак, давайте обсудим возможный алгоритм преобразования:
1. Перевести признак "Обновление резюме" из таблицы с резюме в формат datetime и достать из него дату. В тот же формат привести признак "date" из таблицы с валютами.
2. Выделить из столбца "ЗП" сумму желаемой заработной платы и наименование валюты, в которой она исчисляется. Наименование валюты перевести в стандарт ISO согласно с таблицей выше.
3. Присоединить к таблице с резюме таблицу с курсами по столбцам с датой и названием валюты (подумайте, какой тип объединения надо выбрать, чтобы в таблице с резюме сохранились данные о заработной плате, изначально представленной в рублях). Значение close для рубля заполнить единицей 1 (курс рубля самого к себе)
4. Умножить сумму желаемой заработной платы на присоединенный курс валюты (close) и разделить на пропорцию (обратите внимание на пропуски после объединения в этих столбцах), результат занести в новый столбец "ЗП (руб)".
"""

# Обратимся к специальным интернет-ресурсам для получения данных о курсе валют
er_df = pd.read_csv('ExchangeRates.csv', sep=',')
display(er_df.head())

# В полученной таблице нас будут интересовать столбцы:
    #"currency" - наименование валюты в ISO кодировке,
    #"date" - дата,
    #"proportion" - пропорция,
    #"close" - цена закрытия (последний зафиксированный курс валюты на указанный день).

# Остальные удалим:
er_df.drop(['per', 'time', 'vol'], axis=1, inplace=True)

# Перевести признак "Обновление резюме" из таблицы с резюме в формат datetime и достать из него дату.
hh_df['Обновление резюме'] = pd.to_datetime(hh_df['Обновление резюме'])

# В тот же формат привести признак "date" из таблицы с валютами.
er_df['date'] = pd.to_datetime(er_df['date']).dt.date

# Воспользуемся специальным словарем, чтобы перевести формат валюты к стандарту ISO
currency_to_ISO = {
    'руб.': 'RUB',
    'бел.руб.': 'BYN',
    'KZT': 'KZT',
    'EUR': 'EUR',
    'USD': 'USD',
    'грн.': 'UAH',
    'сум': 'UZS',
    'KGS': 'KGS',
    'AZN': 'AZN'
}

hh_df['salary'] = hh_df['ЗП'].apply(lambda x: x.split(' ')[0].strip())
hh_df['currency'] = hh_df['ЗП'].apply(lambda x: x.split(' ')[1].strip())
hh_df['currency'] = hh_df['currency'].apply(lambda x: currency_to_ISO[x])
hh_df['date'] = hh_df['Обновление резюме'].dt.date

merged = hh_df.merge(er_df, how='left', left_on=['currency','date'], right_on=['currency', 'date'])
merged = merged.fillna(
    {
        'close':1,
        'proportion':1,
    }
)


merged['salary'] = merged['salary'].astype(np.float64)

merged['ЗП (руб)'] = merged['salary'] * merged['close'] / merged['proportion']
merged[merged['currency']!='RUB']

hh_df = merged.drop(['ЗП', 'salary', 'currency', 'date', 'close', 'proportion'], axis=1)

#желаемая медианная заработная плата соискателей в нашей таблице (в рублях)
hh_df['ЗП (руб)'].median()

"""# Исследование зависимостей в данных

### 1. Постройте распределение признака **"Возраст"**.
Опишите распределение, отвечая на следующие вопросы: чему равна мода распределения, каковы предельные значения признака, в каком примерном интервале находится возраст большинства соискателей? Есть ли аномалии для признака возраста, какие значения вы бы причислили к их числу?

*`Совет`: постройте гистограмму и коробчатую диаграмму рядом.*
"""

fig = px.histogram(
    hh_df,
    x='Возраст',
    title='Распределение по возрасту',
    marginal='box'
)
fig.update_layout(yaxis_title="Общее количество")
fig.show()

"""Анализ соискателей по возрасту:

1. Распределение по возрасту почти нормальное, так как мода смещена немного влево.
2. Мода распределения - 30 лет.
3. Предельные значения от 14 до 49 лет.
4. Большинство соискателей в возрасте примерно от 23 до 40 лет.

Анализ по возрасту совпадает с реальным ожиданием, но есть кое-какие аномалии:

1. Есть один соискатель с возрастом 100 лет (опыт правда пару лет).
2. Единственный соискатель с возрастом 14 лет (тут к своим 14 годам опыта на 40 лет)

### 2. Постройте распределение признака **"Опыт работы (месяц)"**.
Опишите данное распределение, отвечая на следующие вопросы: чему равна мода распределения, каковы предельные значения признака, в каком примерном интервале находится опыт работы большинства соискателей? Есть ли аномалии для признака опыта работы, какие значения вы бы причислили к их числу?
*Совет: постройте гистограмму и коробчатую диаграмму рядом.*
"""

fig = px.histogram(
    hh_df,
    nbins = 1200,
    x='Опыт работы (месяц)',
    title='Распределение по опыту работы (в месяцах)',
    marginal='box'
)
fig.update_layout(yaxis_title="Общее количество")
fig.show()

"""Анализ соискателей по опыту:

1. Мода опыта работы - 81 месяц, медианное значение - 100 месяцев
2. Предельные значения - от 1 до 299 месяцев.
3. Большинство кандидатов имеют имеют опыт от 3 до 200 месяцев.

Анализ по опыту совпадает с реальным ожиданием, но есть кое-какие аномалии:

1. Есть кандидат с опытом 99 лет (явный выброс)

### 3. Постройте распределение признака **"ЗП (руб)"**.
Опишите данное распределение, отвечая на следующие вопросы: каковы предельные значения признака, в каком примерном интервале находится заработная плата большинства соискателей? Есть ли аномалии для признака возраста? Обратите внимание на гигантские размеры желаемой заработной платы.

***Совет: постройте гистограмму и коробчатую диаграмму рядом.***
"""

# Найдем сколько соискателей требуют заработную плату выше 1 миллиона рублей
a = hh_df[hh_df['ЗП (руб)'] > 1000000]['ЗП (руб)'].count()
display(f'{a} соискателей требуют заработную плату выше 1 миллиона рублей')


fig = px.histogram(
    hh_df,
    x='ЗП (руб)',
    title='Распределение по размеру желаемой зарплаты (руб)',
    marginal='box'
)
fig.update_layout(yaxis_title="Общее количество")
fig.show()

"""Анализ соискателей по требуемой зарплате:

1. Мода желаемой зарплаты - 50 тысяч рублей.
2. Предельные значения - от 17 500 до 24 300 000 рублей.
3. Большинство соискателей по требует от 22 000 100 000.

Анализ ппо требуемой зарплате без очистки не информативен:

1. Есть кандидаты с очень большим требованием по зарплате, возможно указана плата за год.
2. Параметры зарплаты имеют очень большой разброс, требуется дополнительно отсеить данные.

### 4. Постройте диаграмму, которая показывает зависимость **медианной** желаемой заработной платы (**"ЗП (руб)"**) от уровня образования (**"Образование"**).
Используйте для диаграммы данные о резюме, где желаемая заработная плата меньше 1 млн рублей.
*Сделайте выводы по представленной диаграмме: для каких уровней образования наблюдаются наибольшие и наименьшие уровни желаемой заработной платы? Как вы считаете, важен ли признак уровня образования при прогнозировании заработной платы?*
"""

#Сгруппируем данные по зарплате (до 1 млн) и образованию, выведем медианную зарплату.
group1_df = hh_df[hh_df['ЗП (руб)']<1_000_000].groupby('Образование', as_index=False)['ЗП (руб)'].median()

fig = px.bar(
    group1_df,
    x='Образование',
    y='ЗП (руб)',
    title='Зависимость желаемой зарплаты от образования',
    width=900,
    height=500
)
fig.show()

"""Выводы:
1. Чем выше уровень образования, тем выше требуемая зарплата
2. Уровень образование является важным признаком для уровня требуемой зарплаты.

### 5. Постройте диаграмму, которая показывает распределение желаемой заработной платы (**"ЗП (руб)"**) в зависимости от города (**"Город"**).
Используйте для диаграммы данные о резюме, где желая заработная плата меньше 1 млн рублей.
*Сделайте выводы по полученной диаграмме: как соотносятся медианные уровни желаемой заработной платы и их размах в городах? Как вы считаете, важен ли признак города при прогнозировании заработной платы?*
"""

fig = px.box(
    hh_df[hh_df['ЗП (руб)']<1_000_000],
    x='Город',
    y='ЗП (руб)',
    color='Город'
)
fig.show()

"""Вывод:

Москва лидирует по уровню желаемой зарплаты в 2 раза обгоняя другие города.

6. Постройте **многоуровневую столбчатую диаграмму**, которая показывает зависимость медианной заработной платы (**"ЗП (руб)"**) от признаков **"Готовность к переезду"** и **"Готовность к командировкам"**. Проанализируйте график, сравнив уровень заработной платы в категориях.
"""

group2_df = hh_df.groupby(
    ['Готовность к переезду', 'Готовность к командировкам'],
    as_index=False)['ЗП (руб)'].median()

fig = px.bar(
    group2_df,
    y='Готовность к командировкам',
    x='ЗП (руб)',
    barmode="group",
    color='Готовность к переезду',
    orientation='h',
    title='Медианная з/п по готовности к командировкам/переезду'
)

fig.show()

"""Выводы:

Готовность к командировкам очень сильно поднимает требование к зарплате, чем переезд

### 7. Постройте сводную таблицу, иллюстрирующую зависимость **медианной** желаемой заработной платы от возраста (**"Возраст"**) и образования (**"Образование"**).
На полученной сводной таблице постройте **тепловую карту**. Проанализируйте тепловую карту, сравнив показатели внутри групп.
"""

pivot1_df = hh_df.pivot_table(
    index='Возраст',
    columns='Образование',
    values='ЗП (руб)',
    aggfunc='median',
)

fig = px.imshow(
    pivot1_df,
    color_continuous_scale='dense',
    title='Медианная з/п по образованию и возрасту'
)
fig.update_yaxes(autorange=True)

fig.show()

"""Выводы:
1. Чем выше образование, тем больше возраст кандидатов.
2. Чем выше образование, тем больше желаемая зарплата.
Аномалии:
1. Видно справа вверху метку 100 летнего соискателя
2. Кто-то с высшим образованием и моложе 20 лет просит большую зарплату.

### 8. Постройте **диаграмму рассеяния**, показывающую зависимость опыта работы (**"Опыт работы (месяц)"**) от возраста (**"Возраст"**).
Опыт работы переведите из месяцев в года, чтобы признаки были в едином масштабе. Постройте на графике дополнительно прямую, проходящую через точки (0, 0) и (100, 100).

Данная прямая соответствует значениям, когда опыт работы равен возрасту человека. Точки, лежащие на этой прямой и выше нее - аномалии в наших данных (опыт работы больше либо равен возрасту соискателя)
"""

#Опыт работы переводим из месяцев в года, чтобы признаки были в едином масштабе
hh_df['Опыт работы (лет)'] = hh_df['Опыт работы (месяц)'].apply(
    lambda x: round(x/12,1) if x is not np.nan else np.nan
)

fig = px.scatter(
    hh_df,
    x='Возраст',
    y='Опыт работы (лет)',
    title='Зависимость опыта работы от возраста'
)

fig.add_trace(go.Scatter(x=[0,100], y=[0,100], mode='lines'))
fig.update_layout(yaxis_range=[0,100], xaxis_range=[0,100], showlegend=False)
fig.show()

hh_df = hh_df.drop('Опыт работы (лет)', axis=1)

"""Выводы:
1. В нашших данных есть соискатели с опытом больше чем их возвраст.
2. Большое количество соискателей с близким к нулю опытом

**Дополнительные баллы**

Для получения 2 дополнительных баллов по разведывательному анализу постройте еще два любых содержательных графика или диаграммы, которые помогут проиллюстрировать влияние признаков/взаимосвязь между признаками/распределения признаков. Приведите выводы по ним. Желательно, чтобы в анализе участвовали признаки, которые мы создавали ранее в разделе "Преобразование данных".
"""

#Найдем соотношение по полу соискателя
gender_df = hh_df.groupby(by="Пол", as_index=True)["Пол"].count()

fig = px.pie(
    gender_df,
    values="Пол",
    names=gender_df.index.tolist(),
    hole=.25,
    color_discrete_sequence=["green", "red"],
    height=500,
    width=900,
    title='Соотношение мужчин и женщин среди соискателей'
)
fig.update_traces(
    textposition='inside',
    textinfo='percent+label'
)

fig.show()

"""Мужчин среди соискателей гораздо больше."""

#Найдем соотношение по желаемой зарплате по полу соискателя
fig = px.box(
    hh_df,
    y='Пол',
    x='ЗП (руб)',
    title='Распределение желаемой зарплате по полу соискателя',
    color='Пол',
    height=500,
    width=900
)

#Подправим шкалу, так как выбросы сильно искривляют график
fig.update_layout(xaxis_range=[0,200000], showlegend=False)

"""Женщинам предлагают меньшую зарплату. Но не все согласны с этим.

# Очистка данных

1. Начнем с дубликатов в наших данных. Найдите **полные дубликаты** в таблице с резюме и удалите их.
"""

#Перед очисткой сделаем копию таблицы
new_hh_df = hh_df.copy()

new_hh_df['Обновление резюме'] = new_hh_df['Обновление резюме'].dt.date
new_hh_df['Готовность к командировкам'].fillna(True, inplace=True)
experience_fix = hh_df[ (hh_df['Опыт работы (месяц)'] == 'Не указано') ].index
column_id = new_hh_df.columns.get_loc('Опыт работы (месяц)')
new_hh_df.iloc[experience_fix,column_id] = 0

#Выведем общее количество дубликатов
display(new_hh_df.duplicated().sum())

#Удалим найденные дубликаты
new_hh_df.drop_duplicates(inplace=True)

"""2. Займемся пропусками. Выведите информацию **о числе пропусков** в столбцах."""

hh_df_null = hh_df.isnull().sum()
hh_df_null[hh_df_null > 0]

"""3. Итак, у нас есть пропуски в 3ех столбцах: **"Опыт работы (месяц)"**, **"Последнее/нынешнее место работы"**, **"Последняя/нынешняя должность"**. Поступим следующим образом: удалите строки, где есть пропуск в столбцах с местом работы и должностью. Пропуски в столбце с опытом работы заполните **медианным** значением."""

#Пропуски в признаке "Опыт работы (месяц)" заменим медианным значением
new_hh_df['Опыт работы (месяц)'].fillna(new_hh_df['Опыт работы (месяц)'].median(), inplace=True)

#Остальные строки с пропусками удаляем
new_hh_df.dropna(
    axis='index',
    subset=['Последнее/нынешнее место работы', 'Последняя/нынешняя должность'],
    how='any',
    inplace=True
)

# Найдем результирующее среднее значение в столбце «Опыт работы (месяц)» после заполнения пропусков
display(round(new_hh_df['Опыт работы (месяц)'].mean()))

"""4. Мы добрались до ликвидации выбросов. Сначала очистим данные вручную. Удалите резюме, в которых указана заработная плата либо выше 1 млн. рублей, либо ниже 1 тыс. рублей."""

#Выделим данные по условиям выброса
outliers_1 = new_hh_df[(new_hh_df['ЗП (руб)'] > 1e6) | (new_hh_df['ЗП (руб)'] < 1e3)]

#Удалим строки из данных
new_hh_df = new_hh_df.drop(outliers_1.index)

#Выведем количество удаленных выбросов
outliers_1.shape[0]

"""5. В процессе разведывательного анализа мы обнаружили резюме, в которых **опыт работы в годах превышал возраст соискателя**. Найдите такие резюме и удалите их из данных

"""

#Выделим данные по условиям выброса
outliers_2 = new_hh_df[new_hh_df['Опыт работы (месяц)']/12 >= new_hh_df['Возраст']]

#Удалим строки из данных
new_hh_df = new_hh_df.drop(outliers_2.index)

#Выведем количество удаленных выбросов
outliers_2.shape[0]

"""6. В результате анализа мы обнаружили потенциальные выбросы в признаке **"Возраст"**. Это оказались резюме людей чересчур преклонного возраста для поиска работы. Попробуйте построить распределение признака в **логарифмическом масштабе**. Добавьте к графику линии, отображающие **среднее и границы интервала метода трех сигм**. Напомним, сделать это можно с помощью метода axvline. Например, для построение линии среднего будет иметь вид:

`histplot.axvline(log_age.mean(), color='k', lw=2)`

В какую сторону асимметрично логарифмическое распределение? Напишите об этом в комментарии к графику.
Найдите выбросы с помощью метода z-отклонения и удалите их из данных, используйте логарифмический масштаб. Давайте сделаем послабление на **1 сигму** (возьмите 4 сигмы) в **правую сторону**.

Выведите таблицу с полученными выбросами и оцените, с каким возрастом соискатели попадают под категорию выбросов?
"""

#Возьмем функцию для реализации алгоритма метода z-отклонений
def outliers_z_score_mod(data, feature, log_scale=False, left=3, right=3):
    if log_scale:
        z = np.log(data[feature])
    else:
        z = data[feature]
    mu = z.mean()
    sigma = z.std()
    lower_bound = mu - left * sigma
    upper_bound = mu + right * sigma
    outliers = data[(z < lower_bound) | (z > upper_bound)]
    cleaned = data[(z > lower_bound) & (z < upper_bound)]
    return outliers, cleaned

outliers, cleaned = outliers_z_score_mod(new_hh_df, 'Возраст', log_scale=True, right=4)
display(f'outliers: {outliers.shape[0]}')
display(f'cleaned: {cleaned.shape[0]}')

#display(outliers['Возраст'].unique())
#Возраст соискателей из выброса: 15 и 100 лет!!!


#Построем сравнительные графики распределения по возрасту до и после применения алгоритма метода z-отклонений
fig1 = px.histogram(
    new_hh_df['Возраст']
)

log = np.log(new_hh_df['Возраст']+1)
fig2 = px.histogram(
    log,
    nbins = 10000
)

#Объединим их для наглядности
fig = make_subplots(
    rows=1, cols=2,
    subplot_titles=('Нормальное распределение', 'Логарифмическое распределение')
)
fig.add_trace(fig1['data'][0], row=1, col=1)
fig.add_trace(fig2['data'][0], row=1, col=2)

fig.update_xaxes(title_text='Возраст (норма)', row=1, col=1)
fig.update_xaxes(title_text='Возраст (логарифм)', row=1, col=2)

fig.update_yaxes(title_text="Общее количество", row=1, col=1)
fig.update_yaxes(title_text="Общее количество", row=1, col=2)

fig.update_layout(
    height=500, width=950,
    title_text="Распределение по возрасту",
    showlegend=False
)
fig.show()

"""Выводы:
1. Логарифмическое распределение имеет заметное отклонение влево.
2. Возраст 15 лет и 100 лет попали в выбросы.
"""